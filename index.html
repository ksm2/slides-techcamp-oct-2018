<!doctype html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

  <title>reveal.js</title>

  <link rel="stylesheet" href="css/styles.css">
  <link rel="stylesheet" href="lib/fontawesome/css/all.min.css">
  <link rel="stylesheet" href="css/theme/baqend.css">

  <!-- Printing and PDF exports -->
  <script>
    var link = document.createElement('link')
    link.rel = 'stylesheet'
    link.type = 'text/css'
    link.href = window.location.search.match(/print-pdf/gi) ? 'css/print/pdf.css' : 'css/print/paper.css'
    document.getElementsByTagName('head')[0].appendChild(link)
  </script>
</head>
<body>
<div class="reveal">
  <div class="slides">
    <section>
      <h1>Enhancing Data Processing in Browsers Using Streams</h1>
      <video data-autoplay loop>
        <source src="videos/carrierbelt.webm" type="video/webm"/>
      </video>
      <p class="subtitle">How browsers can handle big data today</p>

      <a class="social-profile" href="https://github.com/ksm2"><i class="fab fa-github"></i> github.com/ksm2</a>
      <a class="social-profile" href="https://twitter.com/k_moellers"><i class="fab fa-twitter"></i> twitter.com/k_moellers</a>
    </section>

    <section data-background="#162939">
      <h2>$ whoami</h2>
      <p>Konstantin MÃ¶llers<br>
        Performance Engineer @ Baqend<br>
        Master of Science @ Uni Hamburg<br>
        Professional working experience for 6 years</p>
      <div class="shooting-star shooting-star-left"><img src="images/shooting-star.png"></div>
      <div class="shooting-star shooting-star-right"><img src="images/shooting-star.png"></div>
      <div class="shooting-star shooting-star-left"><img src="images/shooting-star.png"></div>
      <div class="shooting-star shooting-star-right"><img src="images/shooting-star.png"></div>
      <div class="shooting-star shooting-star-left"><img src="images/shooting-star.png"></div>
      <div class="shooting-star shooting-star-right"><img src="images/shooting-star.png"></div>
    </section>

    <section>
      <div class="whatwg">
        <img src="images/logo-streams.svg" class="whatwg-logo">
        <div class="whatwg-title">
          <h2>Streams API</h2>
          <p class="subtitle">WHATWG Living Standard</p>
        </div>
      </div>

      <video data-autoplay loop>
        <source src="videos/carrierbelt.webm" type="video/webm"/>
      </video>

      <p><a href="https://streams.spec.whatwg.org/" target="_blank" rel="nofollow">https://streams.spec.whatwg.org/</a></p>
    </section>

    <section>
      <h2>Reading a Stream</h2>

      <section>
        <ul>
          <li>a simple, <code>Promise</code>-based API</li>
          <li>blocks others from reading</li>
        </ul>
      </section>

      <section>
        Using <code>Promise</code> chains of ES2015
        <pre><code class="hljs" data-trim data-noescape>
function consumeStreamWithPromiseChains(url) {
  return fetch(url)                  // Fetch a URL
    .then(response => response.body) // Stream the body
    .then(rs => rs.getReader())      // Get a lock on the stream
    .then(reader => reader.read().then(next => consume(reader, next)))
}

function consume(reader, { done, value }) {
  // Exit if we're done and unlock the stream
  if (done) {
    reader.releaseLock()
    return
  }
  console.log(value /* is a Uint8Array */) // Do something with it
  // Wait for the next chunk and consume it
  return reader.read().then(next => consume(reader, next))
}
						</code></pre>
      </section>

      <section>
        Using <code>async</code> and <code>await</code> of ES2017
        <pre><code class="hljs" data-trim>
async function consumeStreamAsyncAwait(url) {
  const response = await fetch(url) // Fetch a URL
  const rs = response.body          // Stream the body
  const reader = rs.getReader()     // Get a lock on the stream

  while (true) {
    // Await more data and return if we are done reading
    const { done, value } = await reader.read()
    if (done) break

    // Do something with the data
    console.log(value)
  }

  // Unlock the stream
  reader.releaseLock()
}
						</code></pre>
      </section>

      <section>
        Using <code>AsyncIterator</code> of ES2018
        <pre><code class="hljs" data-trim>
async function consumeStreamAsyncIterator(url) {
  const response = await fetch(url)         // Fetch a URL
  const rs = response.body                  // Stream the body
  const iterator = streamAsyncIterator(rs)  // Lock and create iterator

  // Await more data while iterating
  for await (const byteArray of iterator) {
    // Do something with the data
    console.log(byteArray)
  }
}
        </code></pre>
      </section>

      <section>
        Implementation of <code>streamAsyncIterator</code>
        <pre><code class="hljs" data-trim>
async function* streamAsyncIterator(rs) {
  // Get a lock on the stream
  const reader = rs.getReader()
  try {
    while (true) {
      // Read from the stream and exit if we're done
      const { done, value } = await reader.read()
      if (done) return
      // Else yield the chunk
      yield value
    }
  }
  finally {
    // Unlock the stream
    reader.releaseLock()
  }
}
        </code></pre>
      </section>

      <section>
        <div class="browser-compat">
          <div class="browser-support">
            <img src="images/browsers/google-chrome.svg">
            <span class="version">43+</span>
          </div>
          <div class="browser-support">
            <img src="images/browsers/mozilla-firefox.svg">
            <span class="version"><i class="fas fa-flag"></i></span>
          </div>
          <div class="browser-support">
            <img src="images/browsers/microsoft-edge.svg">
            <span class="version">16+</span>
          </div>
          <div class="browser-support">
            <img src="images/browsers/opera.svg">
            <span class="version">30+</span>
          </div>
          <div class="browser-support">
            <img src="images/browsers/apple-safari.png">
            <span class="version">10+</span>
          </div>
        </div>
        <p hidden>
          <small>https://www.chromestatus.com/feature/5804334163951616</small>
          <small>https://developer.microsoft.com/en-us/microsoft-edge/platform/status/streamsapireadablestream/</small>
          <small>https://webkit.org/status/#feature-readable-streams</small>
        </p>
      </section>
    </section>

    <section>
      <h2>Creating a Readable Stream</h2>
      <pre><code class="hljs" data-trim>
const rs = new ReadableStream({
  /* Is called when the consumer locks the stream */
  async start(ctrl: ReadableStreamDefaultController): Promise&lt;void&gt; {
    try {
      ctrl.enqueue(chunk)  // Enqueue a new chunk in the stream
      ctrl.close()         // Tell the consumer we have sent all chunks
    } catch (err) {
      ctrl.error(err)      // Forward-propagate an error
    }
  },

  /* Is called when the consumer waits for data */
  async pull(ctrl: ReadableStreamDefaultController): Promise&lt;void&gt; {},

  /* Handle back-propagated errors */
  async cancel(reason: any): Promise&lt;void&gt; {},
})
      </code></pre>
    </section>

    <section>
      <h2>Writing Streams to a Sink</h2>

      <section>
        <p>Writable Streams</p>
        <pre><code class="hljs" data-trim>
const ws = new WritableStream({
  /* Is called when the user starts writing to the stream */
  start(ctrl: WritableStreamDefaultController): Promise&lt;void&gt; {},

  /* Is called when the user sends a new chunk */
  write(chunk: any,
        ctrl: WritableStreamDefaultController): Promise&lt;void&gt; {},

  /* Is called when the user is done writing */
  close(ctrl: WritableStreamDefaultController): Promise&lt;void&gt; {},

  /* Is called when the user aborts to write */
  abort(reason: any): Promise&lt;void&gt; {},
})
        </code></pre>
      </section>

      <section>
        <p>Creating a Writable WebSocket Stream</p>
        <pre><code class="hljs hljs-19" data-trim>
function makeWritableWebSocketStream(url, protocols) {
  const socket = new WebSocket(url, protocols)  // Create the WebSocket
  return new WritableStream({
    start(ctrl) {   // Wait for the socket to be opened
      return new Promise(resolve => socket.onopen = resolve)
    },

    write(chunk) {  // Pass the chunk to the socket
      socket.send(chunk)
    },

    close() {       // Close the socket when closing the stream
      return new Promise((resolve) => {
        socket.onclose = () => resolve()
        socket.close(code)
      })
    },
  })
}
        </code></pre>
      </section>

      <section>
        <p>Using <code>pipeTo</code> with Writable Streams</p>
        <pre><code class="hljs" data-trim>
async function examplePipingTo() {
  // Create a writable stream to a WebSocket
  const ws = makeWritableWebSocketStream('ws://localhost:8080/')
  // Fetch a JSON
  const response = await fetch('https://localhost/some.json')

  // Pipe the JSON's stream to the WebSocket
  response.body.pipeTo(ws)
}
        </code></pre>
      </section>

      <section>
        <div class="browser-compat">
          <div class="browser-support">
            <img src="images/browsers/google-chrome.svg">
            <span class="version">59+</span>
          </div>
          <div class="browser-no-support">
            <img src="images/browsers/mozilla-firefox.svg">
          </div>
          <div class="browser-support">
            <img src="images/browsers/microsoft-edge.svg">
            <span class="version">16+</span>
          </div>
          <div class="browser-support">
            <img src="images/browsers/opera.svg">
            <span class="version">46+</span>
          </div>
          <div class="browser-no-support">
            <img src="images/browsers/apple-safari.png">
          </div>
        </div>
        <p hidden>
          <small>https://www.chromestatus.com/feature/5928498656968704</small>
          <small>https://developer.microsoft.com/en-us/microsoft-edge/platform/status/streamsapiwritablestream/</small>
        </p>
      </section>

    </section>

    <section>
      <h2>Transforming Streams with Pipes</h2>

      <section>
        <p>Transform Streams</p>
        <pre><code class="hljs hljs-19" data-trim>
const ts = new TransformStream({
  /* Is called when the user starts to transform */
  start(ctrl: TransformStreamDefaultController): Promise&lt;void&gt; {},

  /* Is called when a new chunk is sent to be transformed */
  transform(chunk: any,
            ctrl: TransformStreamDefaultController): Promise&lt;void&gt; {},

  /* Is called when all chunks have been sent and we have to finish */
  flush(ctrl: TransformStreamDefaultController): Promise&lt;void&gt; {},
})
        </code></pre>
      </section>

      <section>
        <p>Using <code>pipeThrough</code> with Transform Streams</p>
        <pre><code class="hljs" data-trim>
async function examplePipeThrough() {
}
        </code></pre>
      </section>

      <section>
        <p>Using Identity Transform Streams</p>
        <pre><code class="hljs" data-trim>
function fetchUploadStreamed() {
  // Create an identity transform stream and get its
  // readable and writable streams
  const { writable, readable } = new TransformStream()

  // Link the uploaded body with the readable stream
  fetch('...', { body: readable }).then(response => /* ... */)

  // Lock the writer of the writable stream and write data to it
  const writer = writable.getWriter()
  writer.write(new Uint8Array([0x73, 0x74, 0x72, 0x65, /* ... */]))
  writer.close()
}
        </code></pre>
      </section>

      <section>
        <div class="browser-compat">
          <div class="browser-support">
            <img src="images/browsers/google-chrome.svg">
            <span class="version">67+</span>
          </div>
          <div class="browser-no-support">
            <img src="images/browsers/mozilla-firefox.svg">
            <span class="version"></span>
          </div>
          <div class="browser-no-support">
            <img src="images/browsers/microsoft-edge.svg">
          </div>
          <div class="browser-support">
            <img src="images/browsers/opera.svg">
            <span class="version">54+</span>
          </div>
          <div class="browser-no-support">
            <img src="images/browsers/apple-safari.png">
          </div>
        </div>
        <p hidden>
          <small>https://www.chromestatus.com/feature/5466425791610880</small>
        </p>
      </section>
    </section>

    <section>
      <h2>How to use it?</h2>

      <section>
        <h3>Service Workers</h3>
      </section>

      <section>
        <h3>Demonstration</h3>
        <p><a href="https://github.com/ksm2/targa-service-worker">https://bit.do/ksm-tga</a></p>
      </section>
    </section>
  </div>
</div>

<script src="lib/js/head.min.js"></script>
<script src="js/reveal.js"></script>
<script src="js/custom.js"></script>

<script>
  // More info about config & dependencies:
  // - https://github.com/hakimel/reveal.js#configuration
  // - https://github.com/hakimel/reveal.js#dependencies
  Reveal.initialize({
    history: true,
    dependencies: [
      { src: 'plugin/markdown/marked.js' },
      { src: 'plugin/markdown/markdown.js' },
      { src: 'plugin/notes/notes.js', async: true },
      {
        src: 'plugin/highlight/highlight.js', async: true, callback: function () {
          const js = hljs.getLanguage('js')
          js.k.keyword = `${js.k.keyword} any`
          js.k.built_in = `${js.k.built_in} fetch WebSocket ReadableStream ReadableStreamDefaultController WritableStream WritableStreamDefaultController TransformStream TransformStreamDefaultController`
          js.k.param = `url protocols resolve reject code reasonString done value reader writer readable writable ctrl chunk reason next rs ws ts response iterator byteArray err socket`

          hljs.initHighlightingOnLoad()
        },
      },
    ],
  })
</script>
</body>
</html>
